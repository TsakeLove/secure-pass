# Report on 5/6/7 labs

## Lab 5
Начало 5 лабораторной работы было с того, чтобы определить что такое надежный пароль. Поэтому, я взял топ 100 самых популярных паролей и сравнил их со слитыми, которые мне удалось найти. Взглянув на это, я пришел к выводу о том, что:
- пароль должен быть максимально абстрактным
- пароль не должен содержать в себе имейл
- идеальный пароль - случайный пароль

Для того чтобы максимально приблизить пользователя к тому, чтобы создать надежный пароль я взял библиотеку "password-validator" и использовал ее для того, чтобы:
- пароль содержал минимум 10 символов ( как по мне, это заставит добавить пользователя еще какие-то символы к паролю "пароль" )
- минимум 2 большие буквы
- минимум 2 цифры
- не должен содержать пробел ( имея эту возможность, лично у меня часто закрадывались мысли создать пароль из 8 пробелов или написать два коротких слова через пробел )
- проверка пароля на наличие его в "черном списке" ( так как я уже скачал файл с самыми популярными паролями я сравнивал значение введенного пароля именно с ними)

Что я добавил к возможностям этой библиотеки:
- проверка на наличие пароля в черном списке не зависит от регистра ( pAsWoRd == password )
- проверку на наличие имейла/части имейла в пароле ( мой имейл igor-tsakelov@ilove.igor, соответственно мой пароль не может содержать в себе "igor-tsakelov@ilove.igor", "igor", "tsakelov" )

Ну и для валидации имейла я просто создал регулярное выражение для того, чтобы в поле email было введено хотя бы что-то подобное на имейл.
Подобно имейлу я создал простую регулярку для проверки телефона ( будет использоваться в 6 лабораторной)).

Пароль я зашифровал с помощью argon2i. Я начал писать эту лабу до того, как посмотрел лекции, поэтому первыми шагами в выборе алгоритма шифрования было полазить на формах, почитать какие алгоритмы используются сейчас, узнать что такое адаптация к атаке по времени и как выиграть Password Hashing Competition.

## Lab 6
Начало 6 лабораторной работы было с того, чтобы понять, что какой бы надежный пароль не был, после того как украдут доступ к бд важные данные могут быть слиты.

Именно поэтому я пришел к тому, чтобы зашифровать важные данные с помощью aes-gcm (Galois/Counter Mode - считают шифр и добавляет message authentication code прям в момент шифрования). На выходе я получил два параметра: tag и context. Их я в таком виде и положил в базу данных. Для aes-gcm нужно было 2 параметра: iv и password. Их я взял случайным образом, а после использования зашифровал с помощью KMS от AWS. И уже в таком виде положил в бд.
Процесс дешифровки подобный: взять phone, iv, password из бд, расшифровать iv, password, с их помощью расшифровать phone

Таким образом я пришел к тому, что пользователь вынужден будет создать надежный пароль, а важные данные ( в моем случае телефон ) даже если и будут украдены, то маловероятно будут расшифрованы.

## Lab 7

Для того, чтобы настроить TLS нужно было разобраться что такое TLS. Ознакомившись с материалом можно сделать вывод, что это криптографический протокол, обеспечивающий сквозную защиту данных, передаваемых между приложениями ( **значек замочка рядом со ссылкой**). Суть состоит в том, чтобы обеспечить безопасную доставку данных, предотвращая возможное подслушивание и/или изменение содержимого.

Так как не было в планах деплоить проект, я создал ключ и сертификат для локального сервера с помощью mkcert ( сертификат находится в  "localhost.pem
", а ключ по адресу "localhost-key.pem" ).

После этого, можно запустить сервер, и с помощью nmap проверить какой протокол поддерживает прослушиваемый порт.


